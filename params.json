{"name":"Crawler","body":"# crawler - A DSL for web crawling in Scala\r\n\r\nThe purpose of this project is to provide a nice DSL wrapper around the\r\ncumbersome htmlunit Java library.  Here is an example taken from a unit \r\ntest in this package:\r\n\r\n    class testCrawler extends crawler {\r\n      var result = \"\"\r\n      def crawl = {\r\n        navigateTo(\"http://www.google.com\") {\r\n          in(form having id(\"tsf\")) {\r\n            in(textField having id(\"lst-ib\")) {\r\n              typeIn(\"bplawler\")\r\n            }\r\n            in(submit having name(\"btnK\")) {\r\n              click ==>\r\n            }\r\n          }\r\n        }\r\n        onCurrentPage {\r\n          result = from(div having id(\"resultStats\")) getTextContent\r\n        }\r\n      }\r\n    }\r\n\r\nThis `testCrawler` class defines a crawl that will navigate to google, \r\nfind the form whose id is `tsf`, type something into the form, then\r\nclick on the submit button named `btnK`, which will then take us to a \r\nnew page (the search results) where we can then grab the content of the\r\n`resultStats` div.\r\n\r\n## Background\r\n\r\nThis DSL was created to simplify the code needed to programmatically access\r\nweb pages and do something meaningful with the content.  It is backed by the\r\nJava [HtmlUnit](http://htmlunit.sourceforge.net/) library, which, according to\r\ntheir web site, provides a \"GUI-less browser for Java programs.\"  The library\r\nis very good at what it does, but I found that using it generally resulted in\r\ncode that was pretty difficult to read.\r\n\r\nThis DSL is also my first attempt to write such a thing in Scala, so really \r\nthis is just sort of an academic project to learn as much as I can about Scala\r\nand about writing DSL's in Scala.  There are a few brittle areas in this thing\r\nthat could greatly benefit from some clear error handling, but for what I \r\nwas trying to do, the code here did the trick just fine.\r\n\r\n## Basic Language Structure\r\n\r\nThe first part of any web crawl is to provide a starting point.  This is \r\ndone with the `navigateTo` method.  `navigateTo` takes a string and is \r\nfollowed by the code block that contains the stuff you want to do with\r\nthis page.\r\n\r\n    navigateTo(\"http://www.google.com\") { ... }\r\n\r\nInside the code block, you can use the DSL keywords to find individual HTML\r\nelements and do operations on those things.  On of the more common keywords is\r\n`in`, which receives as an argument a bit of code that identifies an HTML\r\nnode on the current page, then opens another code block to do processing within\r\nthat HTML node.  The following excerpt will navigate to the google home page\r\nand find the form element that has an id of `tsf`.\r\n\r\n    navigateTo(\"http://www.google.com\") {\r\n      in(form having id(\"tsf\")) { ... }\r\n    }\r\n\r\nThe code block after the `in` call will operate on the form element that was\r\nfound.  If there was no form with that id on the page, you'll get an error \r\nbut it will be the one that is generated by HtmlUnit - I have not yet made \r\nany effort to wrap the errors nicely.  Inside the code block for this form,\r\nwe can do things like access the individual input fields and enter in \r\nvalues.\r\n\r\n    navigateTo(\"http://www.google.com\") {\r\n      in(form having id(\"tsf\")) {\r\n        in(textField having id(\"lst-ib\")) {\r\n          typeIn(\"bplawler\")\r\n        }\r\n        ...\r\n      }\r\n    }\r\n\r\nHere we have expanded the example to find the text field on the Google home\r\npage and type in a search term.  With this typed in, the next thing we will\r\nwant to do is submit the form and do our search.\r\n\r\n    navigateTo(\"http://www.google.com\") {\r\n      in(form having id(\"tsf\")) {\r\n        in(textField having id(\"lst-ib\")) {\r\n          typeIn(\"bplawler\")\r\n        }\r\n        in(submit having name(\"btnK\") {\r\n          click ==>\r\n        }\r\n      }\r\n    }\r\n\r\nClicking the button is as easy as finding the submit button in the HTML and\r\ncalling `click`.  But what is that wierd `==>` operator?  It turns out that\r\nthis click on our GUI-less browser will take us to a new web page.  The \r\n`==>` operator without an argument signifies that this new page is the next\r\npage we will be working with.  So rather than having to use `navigateTo` \r\nagain, we can simply end this code block and use the `onCurrentPage` method\r\nto start our next code block.\r\n\r\n    navigateTo(\"http://www.google.com\") { ... }\r\n    onCurrentPage {\r\n      result = from(div having id(\"resultStats\")) getTextContent\r\n    }\r\n\r\nIn this example, what we are doing is using the `from` keyword to find a \r\nparticular HTML element (just as with `in`) but this time we are going to \r\nget something out of the element and put that value in a variable.  Remember \r\nthat this DSL is just an extension of Scala, and that we could also just as\r\neasily now call out to another method from within here and do some meaningful\r\nwork.  One other keyword that is supported is `forAll` which receives an\r\n[XPath](http://www.w3schools.com/xpath/) and a subsequent code block over\r\nwhich all of the items in the list will be run.\r\n\r\n    navigateTo(\"http://www.google.com\") { ... }\r\n    onCurrentPage {\r\n      result = from(div having id(\"resultStats\")) getTextContent\r\n      \r\n      forAll(div having xPath(\"\"\"//ol[@id = \"rso\"]/li/div[@class = \"vsc\"]\"\"\")) {\r\n        println(from(anchor having xPath(\"h3/a\")) getTextContent)\r\n      }\r\n    }\r\n\r\nThis invocation of `forAll` will loop through each individual search result\r\nand print out the main anchor text for each.\r\n","tagline":"Scala DSL for web crawling","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}